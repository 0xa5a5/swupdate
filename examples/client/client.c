/*
 * (C) Copyright 2015
 * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

/*
 * This is a simple example how to control swupdate
 * triggering for a new update, streaming an image and asking for the result.
 * This program is not thought to be used as it is, but as example
 * how to use the swupdateipc library.
 * A common use case is when swupdate is in double-copy option
 * and not in rescue, and the communication with the external world
 * is realized by a custom application. The new software image can be
 * also loaded by the main application and then streamed to swupdate
 * via the IPC protocol.
 *
 * The library performs an async update: the user initializes the
 * library with callbacks that are called for each phase of the update process.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include "network_ipc.h"

void usage(void) {
	printf("client <image .swu to be installed>\n");
}

char buf[256];
int fd;
int verbose = 1;

pthread_mutex_t mymutex;

/*
 * this is the callback to get a new chunk of the
 * image.
 * It is called by a thread generated by the library and
 * can block.
 */
int readimage(char **p, int *size) {
	int ret;

	ret = read(fd, buf, sizeof(buf));

	*p = buf;

	*size = ret;

	return ret;
}

/*
 * This is called by the library to inform
 * about the current status of the upgrade
 */
int printstatus(ipc_message *msg)
{
	if (verbose)
		printf("Status: %d message: %s\n",
			msg->data.status.current,
			msg->data.status.desc ? msg->data.status.desc : "");
}

/*
 * this is called at the end reporting the status
 * of the upgrade
 */
int end(RECOVERY_STATUS status)
{
	printf("Swupdate %s\n",
		status == FAILURE ? "*failed* !" :
			"was successful !");

	pthread_mutex_unlock(&mymutex);
}

/*
 * Simple example, it does nothing but calling the library
 */
int main(int argc, char *argv[]) {
	int c;
	const char *fn;
	int rc;
	char *progname;


	pthread_mutex_init(&mymutex, NULL);

	/* parse command line options */
	while ((c = getopt(argc, argv, "hqv")) != EOF) {
		switch (c) {
		case 'h':
			usage();
			return(0);
		case 'q':
			verbose = 0;
			break;
		case 'v':
			verbose++;
			break;
		default:
			usage;
			return(-1);
		}
	}
	argc -= optind;
	argv += optind;

	/* remaining arguments are the filename spec */
	if (argc > 0) {
		if (strcmp(argv[0], "-") == 0) {
			/* already the default, just offered for traditional purposes */
			/* EMPTY */
		} else {
			fn = argv[0];
			argc--; argv++;
		}
	}

	if ( (fd = open(fn, O_RDONLY)) < 0) {
		printf ("I cannot open %s\n", fn);
		exit(1);
	}

	/* synchronize with a mutex */
	pthread_mutex_lock(&mymutex);
	rc = swupdate_async_start(readimage, printstatus,
				end);

	/* Now block */
	pthread_mutex_lock(&mymutex);

	/* End called, unlock and exit */
	pthread_mutex_unlock(&mymutex);
	sleep(1);

	exit(0);
}

